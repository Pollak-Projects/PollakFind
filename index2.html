<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <title>PollakFind</title>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #fff;
            height: 100vh;
            margin: 0;
        }
        h1 {
            font-size: 3rem;
            font-weight: 600;
            margin-bottom: 20px;
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
        }
        .select-container {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
        }
        select, button {
            padding: 10px;
            border-radius: 5px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
        }
        button {
            background: #e74c3c;
            color: white;
            cursor: pointer;
            transition: 0.3s;
        }
        button:hover {
            background: #c0392b;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(20, 50px);
            gap: 2px;
            border: 3px solid #fff;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        .grid div {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            font-weight: bold;
            transition: 0.3s;
            color: black;
        }
        .grid .obstacle {
            background: #2c3e50;
            color: transparent;
        }
        .grid .start {
            background: #27ae60;
            color: white;
        }
        .grid .end {
            background: #e74c3c;
            color: white;
        }
        .grid .path {
            background: #f1c40f !important;
            color: white;
        }
        .grid .black {
            background: #000;
            color: transparent;
        }
    </style>
</head>
<body>
    <h1>PollakFind</h1>
    <div class="select-container">
        <label for="start">Indulási hely:</label>
        <select id="start">
            <option value="info6">info6</option>
            <option value="cad">cad</option>
            <option value="mat3">mat3</option>
            <option value="mat2">mat2</option>
            <option value="nylab">nylab</option>
            <option value="tori">tori</option>
            <option value="lepcso">lepcso</option>
        </select>
        <label for="end">Cél:</label>
        <select id="end">
            <option value="info6">info6</option>
            <option value="cad">cad</option>
            <option value="mat3">mat3</option>
            <option value="mat2">mat2</option>
            <option value="nylab">nylab</option>
            <option value="tori">tori</option>
            <option value="lepcso">lepcso</option>
        </select>
        <button onclick="runPathfinding()">Tanterem keresése</button>
    </div>
    <div class="grid" id="grid"></div>
    <script>
        const gridSize = 20;
        const cellNames = {
            "cell-0-0": "X",
            "cell-0-1": "X",
            "cell-0-2": "X",
            "cell-0-3": "info6",
            "cell-0-4": "X",
            "cell-0-5": "X",
            "cell-0-6": "cad",
            "cell-0-7": "X",
            "cell-0-8": "X",
            "cell-0-9": "X",
            "cell-0-10": "mat3",
            "cell-0-11": "X",
            "cell-0-12": "mat2",
            "cell-0-13": "X",
            "cell-0-14": "X",
            "cell-0-15": "Főbej",
            "cell-1-17": "Aula",
            "cell-2-12": "nylab",
            "cell-2-3": "tori",
            "cell-2-4": "X",
            "cell-2-5": "X",
            "cell-2-6": "X",
            "cell-2-7": "X",
            "cell-2-8": "X",
            "cell-2-9": "X",
            "cell-2-10": "X",
            "cell-2-11": "X",
            "cell-2-13": "X",
            "cell-3-14": "Ebedl",
            "cell-3-13": "X",
            "cell-4-13": "X",
            "cell-2-0": "HBej",
            "cell-3-1": "Nwc",
            "cell-4-1": "X",
            "cell-3-0": "X",
            "cell-4-2": "X",
            "cell-4-3": "X",
            "cell-3-3": "X",
            "cell-3-2": "X",
            "cell-1-0": "lepcso",
            "cell-4-0": "X",  // Example of blacked-out cell (wall)
            // Add more custom names here
        };

        let grid = [];

        document.addEventListener("DOMContentLoaded", function() {
            createGrid(gridSize);
        });

        function createGrid(columns) {
            const gridElement = document.getElementById("grid");
            gridElement.innerHTML = ''; // Clear any existing grid

            grid = [];
            const rows = Math.ceil(100 / columns); // Dynamic number of rows based on column count

            for (let row = 0; row < rows; row++) {
                let rowArray = [];
                for (let col = 0; col < columns; col++) {
                    const cell = document.createElement("div");
                    const cellId = `cell-${row}-${col}`;
                    cell.id = cellId;
                    cell.setAttribute("data-row", row);
                    cell.setAttribute("data-col", col);

                    // Check if the cell has a predefined name
                    if (cellNames[cellId]) {
                        const name = cellNames[cellId];
                        if (name === "X") {
                            cell.classList.add("black");
                            cell.innerText = ""; // Empty text when black
                        } else {
                            cell.innerText = name;
                        }
                    }

                    rowArray.push(cell);
                    gridElement.appendChild(cell);
                }
                grid.push(rowArray);
            }
        }

        function runPathfinding() {
            const start = document.getElementById("start").value;
            const end = document.getElementById("end").value;

            const startPos = findCellPositionByName(start);
            const endPos = findCellPositionByName(end);

            const startCell = grid[startPos.row][startPos.col];
            const endCell = grid[endPos.row][endPos.col];

            document.querySelectorAll(".grid div").forEach(cell => cell.classList.remove("start", "end", "path"));

            if (startCell) startCell.classList.add("start");
            if (endCell) endCell.classList.add("end");

            // A* pathfinding logic
            const path = aStar(startPos, endPos);

            if (path.length > 0) {
                path.forEach(cell => cell.classList.add("path"));
            } else {
                alert("No path found!");
            }
        }

        function findCellPositionByName(name) {
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    if (grid[row][col].innerText === name) {
                        return { row, col };
                    }
                }
            }
            return null; // No cell with that name
        }

        // A* algorithm implementation
        function aStar(startPos, endPos) {
            const openList = [];
            const closedList = [];
            const gScore = [];
            const fScore = [];
            const parent = [];
            const directions = [
                [-1, 0], // up
                [1, 0], // down
                [0, -1], // left
                [0, 1] // right
            ];

            // Initialize all scores to infinity
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid[row].length; col++) {
                    gScore[`${row},${col}`] = Infinity;
                    fScore[`${row},${col}`] = Infinity;
                }
            }

            gScore[`${startPos.row},${startPos.col}`] = 0;
            fScore[`${startPos.row},${startPos.col}`] = heuristic(startPos, endPos);

            openList.push(startPos);

            while (openList.length > 0) {
                // Get the cell with the lowest fScore
                let current = openList.reduce((lowest, node) => 
                    fScore[`${node.row},${node.col}`] < fScore[`${lowest.row},${lowest.col}`] ? node : lowest
                );

                if (current.row === endPos.row && current.col === endPos.col) {
                    return reconstructPath(parent, current);
                }

                openList.splice(openList.indexOf(current), 1);
                closedList.push(current);

                for (let dir of directions) {
                    let newRow = current.row + dir[0];
                    let newCol = current.col + dir[1];

                    if (isValidMove(newRow, newCol) 
                    && !closedList.some(c => c.row === newRow 
                    && c.col === newCol) 
                    && !isBlackCell(newRow, newCol)
                    && !notDestinationRoom(newRow, newCol)
                    )  {
                        const tentativeG = gScore[`${current.row},${current.col}`] + 1;

                        if (tentativeG < gScore[`${newRow},${newCol}`]) {
                            parent[`${newRow},${newCol}`] = current;
                            gScore[`${newRow},${newCol}`] = tentativeG;
                            fScore[`${newRow},${newCol}`] = gScore[`${newRow},${newCol}`] + heuristic({ row: newRow, col: newCol }, endPos);
                            if (!openList.some(c => c.row === newRow && c.col === newCol)) {
                                openList.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }
            }

            return []; // No path found
        }

        function isValidMove(row, col) {
            return row >= 0 && col >= 0 && row < grid.length && col < grid[0].length;
        }

        function notDestinationRoom(row, col){
            return !grid[row][col].classList.contains("end")
            && !grid[row][col].classList.contains("start")
            && grid[row][col].innerHTML !== "";
        }

        function isBlackCell(row, col) {
            return grid[row][col].classList.contains("black");
        }

        function heuristic(a, b) {
            return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
        }

        function reconstructPath(parent, current) {
            let path = [];
            while (current) {
                path.push(grid[current.row][current.col]);
                current = parent[`${current.row},${current.col}`];
            }
            return path.reverse();
        }
    </script>
</body>
</html>
